<?php

namespace Engine;

class Session
{
    protected $adapter;
    protected $session_id;
    public array $data = [];
    public function __construct($session_engine, $di)
    {
        $session_engine = "App\\Session\\$session_engine";
        if (class_exists($session_engine)) {
            $this->adapter = new $session_engine($di);

            register_shutdown_function([&$this, 'close']);
            register_shutdown_function([&$this, 'gc']);
        } else {
            throw new \Exception('Error: Could not load session adaptor ' . $session_engine . ' session!');
        }
    }

    public function getId()
    {
        return $this->session_id;
    }

    public function start($session_id = null)
    {
        // prevent the start function called multiple times
        if (session_status() !== PHP_SESSION_ACTIVE) {
            // session_name to get /set the current session, and should called before the session_start()
            session_name(\App\Config::session_name);
            // session_id needs to called before session_start
            session_start();
            if ($session_id === null) {
                $session_id = session_id();
                // if (function_exists('random_bytes')) {
                //     $session_id = substr(bin2hex(random_bytes(26)), 0, 26);
                // } else {
                //     $session_id = substr(bin2hex(openssl_random_pseudo_bytes(26)), 0, 26);
                // }
            }
            // preg_match('/^[a-zA-Z0-9,\-]{22,52}$/', $session_id) -> this is for custom session id generated by the custom algo

            // check if valid session id
            if (!preg_match('/^[-,a-zA-Z0-9]{1,128}$/', $session_id)) {
                throw new \Exception('Error: Invalid session ID!');
            }
            $this->session_id = $session_id;
        }

        $this->data = $this->adapter->read($session_id);

        return $session_id;
    }

    public function close()
    {
        if (session_status() === PHP_SESSION_ACTIVE) {
            $this->adapter->write($this->session_id, $this->data);
            session_write_close();
        }
    }
    public function gc()
    {
        $this->adapter->gc($this->session_id);
    }

    public function destroy()
    {
        $this->data = [];
        $this->adapter->destroy($this->session_id);
        // The use of session_unset() is identical to $_SESSION = [].
        session_unset();
        // session destroy not clear any data related with the superglobal var $_SESSION
        session_destroy();
        $this->session_id = null;
    }
}
